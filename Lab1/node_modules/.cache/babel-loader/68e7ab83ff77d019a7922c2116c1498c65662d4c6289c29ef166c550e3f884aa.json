{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar LRU = require('lru-cache');\nvar resolveCommand = require('./resolveCommand');\nvar hasBrokenSpawn = require('./hasBrokenSpawn');\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({\n  max: 50,\n  maxAge: 30 * 1000\n}); // Cache just for 30sec\n\nfunction readShebang(command) {\n  var buffer;\n  var fd;\n  var match;\n  var shebang;\n\n  // Check if it is in the cache first\n  if (shebangCache.has(command)) {\n    return shebangCache.get(command);\n  }\n\n  // Read the first 150 bytes from the file\n  buffer = new Buffer(150);\n  try {\n    fd = fs.openSync(command, 'r');\n    fs.readSync(fd, buffer, 0, 150, 0);\n    fs.closeSync(fd);\n  } catch (e) {/* empty */}\n\n  // Check if it is a shebang\n  match = buffer.toString().trim().match(/#!(.+)/i);\n  if (match) {\n    shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, ''); // Remove /usr/bin/env\n  }\n\n  // Store the shebang in the cache\n  shebangCache.set(command, shebang);\n  return shebang;\n}\nfunction escapeArg(arg, quote) {\n  // Convert to string\n  arg = '' + arg;\n\n  // If we are not going to quote the argument,\n  // escape shell metacharacters, including double and single quotes:\n  if (!quote) {\n    arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n  } else {\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = '\"' + arg + '\"';\n  }\n  return arg;\n}\nfunction escapeCommand(command) {\n  // Do not escape if this command is not dangerous..\n  // We do this so that commands like \"echo\" or \"ifconfig\" work\n  // Quoting them, will make them unaccessible\n  return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\nfunction requiresShell(command) {\n  return !/\\.(?:com|exe)$/i.test(command);\n}\nfunction parse(command, args, options) {\n  var shebang;\n  var applyQuotes;\n  var file;\n  var original;\n  var shell;\n\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n  options = options || {};\n  original = command;\n  if (isWin) {\n    // Detect & add support for shebangs\n    file = resolveCommand(command);\n    file = file || resolveCommand(command, true);\n    shebang = file && readShebang(file);\n    shell = options.shell || hasBrokenSpawn;\n    if (shebang) {\n      args.unshift(file);\n      command = shebang;\n      shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));\n    } else {\n      shell = shell || requiresShell(file);\n    }\n    if (shell) {\n      // Escape command & arguments\n      applyQuotes = command !== 'echo'; // Do not quote arguments for the special \"echo\" command\n      command = escapeCommand(command);\n      args = args.map(function (arg) {\n        return escapeArg(arg, applyQuotes);\n      });\n\n      // Use cmd.exe\n      args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n      command = process.env.comspec || 'cmd.exe';\n\n      // Tell node's spawn that the arguments are already escaped\n      options.windowsVerbatimArguments = true;\n    }\n  }\n  return {\n    command: command,\n    args: args,\n    options: options,\n    file: file,\n    original: original\n  };\n}\nmodule.exports = parse;","map":{"version":3,"names":["fs","require","LRU","resolveCommand","hasBrokenSpawn","isWin","process","platform","shebangCache","max","maxAge","readShebang","command","buffer","fd","match","shebang","has","get","Buffer","openSync","readSync","closeSync","e","toString","trim","replace","set","escapeArg","arg","quote","escapeCommand","test","requiresShell","parse","args","options","applyQuotes","file","original","shell","Array","isArray","slice","unshift","map","length","join","env","comspec","windowsVerbatimArguments","module","exports"],"sources":["/home/redundunt/WebstormProjects/untitled/node_modules/gm/node_modules/cross-spawn/lib/parse.js"],"sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar LRU = require('lru-cache');\nvar resolveCommand = require('./resolveCommand');\nvar hasBrokenSpawn = require('./hasBrokenSpawn');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({ max: 50, maxAge: 30 * 1000 });  // Cache just for 30sec\n\nfunction readShebang(command) {\n    var buffer;\n    var fd;\n    var match;\n    var shebang;\n\n    // Check if it is in the cache first\n    if (shebangCache.has(command)) {\n        return shebangCache.get(command);\n    }\n\n    // Read the first 150 bytes from the file\n    buffer = new Buffer(150);\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, 150, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* empty */ }\n\n    // Check if it is a shebang\n    match = buffer.toString().trim().match(/#!(.+)/i);\n\n    if (match) {\n        shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, '');   // Remove /usr/bin/env\n    }\n\n    // Store the shebang in the cache\n    shebangCache.set(command, shebang);\n\n    return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n    // Convert to string\n    arg = '' + arg;\n\n    // If we are not going to quote the argument,\n    // escape shell metacharacters, including double and single quotes:\n    if (!quote) {\n        arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n    } else {\n        // Sequence of backslashes followed by a double quote:\n        // double up all the backslashes and escape the double quote\n        arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n        // Sequence of backslashes followed by the end of the string\n        // (which will become a double quote later):\n        // double up all the backslashes\n        arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n        // All other backslashes occur literally\n\n        // Quote the whole thing:\n        arg = '\"' + arg + '\"';\n    }\n\n    return arg;\n}\n\nfunction escapeCommand(command) {\n    // Do not escape if this command is not dangerous..\n    // We do this so that commands like \"echo\" or \"ifconfig\" work\n    // Quoting them, will make them unaccessible\n    return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction requiresShell(command) {\n    return !/\\.(?:com|exe)$/i.test(command);\n}\n\nfunction parse(command, args, options) {\n    var shebang;\n    var applyQuotes;\n    var file;\n    var original;\n    var shell;\n\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : [];  // Clone array to avoid changing the original\n    options = options || {};\n    original = command;\n\n    if (isWin) {\n        // Detect & add support for shebangs\n        file = resolveCommand(command);\n        file = file || resolveCommand(command, true);\n        shebang = file && readShebang(file);\n        shell = options.shell || hasBrokenSpawn;\n\n        if (shebang) {\n            args.unshift(file);\n            command = shebang;\n            shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));\n        } else {\n            shell = shell || requiresShell(file);\n        }\n\n        if (shell) {\n            // Escape command & arguments\n            applyQuotes = (command !== 'echo');  // Do not quote arguments for the special \"echo\" command\n            command = escapeCommand(command);\n            args = args.map(function (arg) {\n                return escapeArg(arg, applyQuotes);\n            });\n\n            // Use cmd.exe\n            args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n            command = process.env.comspec || 'cmd.exe';\n\n            // Tell node's spawn that the arguments are already escaped\n            options.windowsVerbatimArguments = true;\n        }\n    }\n\n    return {\n        command: command,\n        args: args,\n        options: options,\n        file: file,\n        original: original,\n    };\n}\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}