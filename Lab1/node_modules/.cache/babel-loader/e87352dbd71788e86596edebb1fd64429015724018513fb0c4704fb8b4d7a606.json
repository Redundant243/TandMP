{"ast":null,"code":"/**\n * Extend proto.\n */\n\nmodule.exports = function (gm) {\n  var proto = gm.prototype;\n\n  /**\n   * `identify` states\n   */\n\n  const IDENTIFYING = 1;\n  const IDENTIFIED = 2;\n\n  /**\n   * Map getter functions to output names.\n   *\n   * - format: specifying the -format argument (see man gm)\n   * - verbose: use -verbose instead of -format (only if necessary b/c its slow)\n   * - helper: use the conversion helper\n   */\n\n  var map = {\n    'format': {\n      key: 'format',\n      format: '%m ',\n      helper: 'Format'\n    },\n    'depth': {\n      key: 'depth',\n      format: '%q'\n    },\n    'filesize': {\n      key: 'Filesize',\n      format: '%b'\n    },\n    'size': {\n      key: 'size',\n      format: '%wx%h ',\n      helper: 'Geometry'\n    },\n    'color': {\n      key: 'color',\n      format: '%k',\n      helper: 'Colors'\n    },\n    'orientation': {\n      key: 'Orientation',\n      format: '%[EXIF:Orientation]',\n      helper: 'Orientation'\n    },\n    'res': {\n      key: 'Resolution',\n      verbose: true\n    }\n  };\n\n  /**\n   * Getter functions\n   */\n\n  Object.keys(map).forEach(function (getter) {\n    proto[getter] = function (opts, callback) {\n      if (!callback) callback = opts, opts = {};\n      if (!callback) return this;\n      var val = map[getter],\n        key = val.key,\n        self = this;\n      if (self.data[key]) {\n        callback.call(self, null, self.data[key]);\n        return self;\n      }\n      self.on(getter, callback);\n      self.bufferStream = !!opts.bufferStream;\n      if (val.verbose) {\n        self.identify(opts, function (err, stdout, stderr, cmd) {\n          if (err) {\n            self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          } else {\n            self.emit(getter, err, self.data[key]);\n          }\n        });\n        return self;\n      }\n      var args = makeArgs(self, val);\n      self._exec(args, function (err, stdout, stderr, cmd) {\n        if (err) {\n          self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          return;\n        }\n        var result = (stdout || '').trim();\n        if (val.helper in helper) {\n          helper[val.helper](self.data, result);\n        } else {\n          self.data[key] = result;\n        }\n        self.emit(getter, err, self.data[key]);\n      });\n      return self;\n    };\n  });\n\n  /**\n   * identify command\n   *\n   * Overwrites all internal data with the parsed output\n   * which is more accurate than the fast shortcut\n   * getters.\n   */\n\n  proto.identify = function identify(opts, callback) {\n    // identify with pattern\n    if (typeof opts === 'string') {\n      opts = {\n        format: opts\n      };\n    }\n    if (!callback) callback = opts, opts = {};\n    if (!callback) return this;\n    if (opts && opts.format) return identifyPattern.call(this, opts, callback);\n    var self = this;\n    if (IDENTIFIED === self._identifyState) {\n      callback.call(self, null, self.data);\n      return self;\n    }\n    self.on('identify', callback);\n    if (IDENTIFYING === self._identifyState) {\n      return self;\n    }\n    self._identifyState = IDENTIFYING;\n    self.bufferStream = !!opts.bufferStream;\n    var args = makeArgs(self, {\n      verbose: true\n    });\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n      err = parse(stdout, self);\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n      self.data.path = self.source;\n      self.emit('identify', null, self.data);\n      self._identifyState = IDENTIFIED;\n    });\n    return self;\n  };\n\n  /**\n   * identify with pattern\n   *\n   * Execute `identify -format` with custom pattern\n   */\n\n  function identifyPattern(opts, callback) {\n    var self = this;\n    self.bufferStream = !!opts.bufferStream;\n    var args = makeArgs(self, opts);\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        return callback.call(self, err, undefined, stdout, stderr, cmd);\n      }\n      callback.call(self, err, (stdout || '').trim());\n    });\n    return self;\n  }\n\n  /**\n   * Parses `identify` responses.\n   *\n   * @param {String} stdout\n   * @param {Gm} self\n   * @return {Error} [optionally]\n   */\n\n  function parse(stdout, self) {\n    // normalize\n    var parts = (stdout || \"\").trim().replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n\n    // skip the first line (its just the filename)\n    parts.shift();\n    try {\n      var len = parts.length,\n        rgx1 = /^( *)(.+?): (.*)$/ // key: val\n        ,\n        rgx2 = /^( *)(.+?):$/ // key: begin nested object\n        ,\n        out = {\n          indent: {}\n        },\n        level = null,\n        lastkey,\n        i = 0,\n        res,\n        o;\n      for (; i < len; ++i) {\n        res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);\n        if (!res) continue;\n        var indent = res[1].length,\n          key = res[2] ? res[2].trim() : '';\n        if ('Image' == key || 'Warning' == key) continue;\n        var val = res[3] ? res[3].trim() : null;\n\n        // first iteration?\n        if (null === level) {\n          level = indent;\n          o = out.root = out.indent[level] = self.data;\n        } else if (indent < level) {\n          // outdent\n          if (!(indent in out.indent)) {\n            continue;\n          }\n          o = out.indent[indent];\n        } else if (indent > level) {\n          // dropping into a nested object\n          out.indent[level] = o;\n          // weird format, key/val pair with nested children. discard the val\n          o = o[lastkey] = {};\n        }\n        level = indent;\n        if (val) {\n          // if previous key was exist and we got the same key\n          // cast it to an array.\n          if (o.hasOwnProperty(key)) {\n            // cast it to an array and dont forget the previous value\n            if (!Array.isArray(o[key])) {\n              var tmp = o[key];\n              o[key] = [tmp];\n            }\n\n            // set value\n            o[key].push(val);\n          } else {\n            o[key] = val;\n          }\n          if (key in helper) {\n            helper[key](o, val);\n          }\n        }\n        lastkey = key;\n      }\n    } catch (err) {\n      err.message = err.message + \"\\n\\n  Identify stdout:\\n  \" + stdout;\n      return err;\n    }\n  }\n\n  /**\n   * Create an argument array for the identify command.\n   *\n   * @param {gm} self\n   * @param {Object} val\n   * @return {Array}\n   */\n\n  function makeArgs(self, val) {\n    var args = ['identify', '-ping'];\n    if (val.format) {\n      args.push('-format', val.format);\n    }\n    if (val.verbose) {\n      args.push('-verbose');\n    }\n    args = args.concat(self.src());\n    return args;\n  }\n\n  /**\n   * Map exif orientation codes to orientation names.\n   */\n\n  var orientations = {\n    '1': 'TopLeft',\n    '2': 'TopRight',\n    '3': 'BottomRight',\n    '4': 'BottomLeft',\n    '5': 'LeftTop',\n    '6': 'RightTop',\n    '7': 'RightBottom',\n    '8': 'LeftBottom'\n  };\n\n  /**\n   * identify -verbose helpers\n   */\n\n  var helper = gm.identifyHelpers = {};\n  helper.Geometry = function Geometry(o, val) {\n    // We only want the size of the first frame.\n    // Each frame is separated by a space.\n    var split = val.split(\" \").shift().split(\"x\");\n    var width = parseInt(split[0], 10);\n    var height = parseInt(split[1], 10);\n    if (o.size && o.size.width && o.size.height) {\n      if (width > o.size.width) o.size.width = width;\n      if (height > o.size.height) o.size.height = height;\n    } else {\n      o.size = {\n        width: width,\n        height: height\n      };\n    }\n  };\n  helper.Format = function Format(o, val) {\n    o.format = val.split(\" \")[0];\n  };\n  helper.Depth = function Depth(o, val) {\n    o.depth = parseInt(val, 10);\n  };\n  helper.Colors = function Colors(o, val) {\n    o.color = parseInt(val, 10);\n  };\n  helper.Orientation = function Orientation(o, val) {\n    if (val in orientations) {\n      o['Profile-EXIF'] || (o['Profile-EXIF'] = {});\n      o['Profile-EXIF'].Orientation = val;\n      o.Orientation = orientations[val];\n    } else {\n      o.Orientation = val || 'Unknown';\n    }\n  };\n};","map":{"version":3,"names":["module","exports","gm","proto","prototype","IDENTIFYING","IDENTIFIED","map","key","format","helper","verbose","Object","keys","forEach","getter","opts","callback","val","self","data","call","on","bufferStream","identify","err","stdout","stderr","cmd","emit","args","makeArgs","_exec","result","trim","identifyPattern","_identifyState","parse","path","source","undefined","parts","replace","split","shift","len","length","rgx1","rgx2","out","indent","level","lastkey","i","res","o","exec","root","hasOwnProperty","Array","isArray","tmp","push","message","concat","src","orientations","identifyHelpers","Geometry","width","parseInt","height","size","Format","Depth","depth","Colors","color","Orientation"],"sources":["/home/redundunt/WebstormProjects/untitled/node_modules/gm/lib/getters.js"],"sourcesContent":["/**\n * Extend proto.\n */\n\nmodule.exports = function (gm) {\n\n  var proto = gm.prototype;\n\n  /**\n   * `identify` states\n   */\n\n  const IDENTIFYING = 1;\n  const IDENTIFIED = 2;\n\n  /**\n   * Map getter functions to output names.\n   *\n   * - format: specifying the -format argument (see man gm)\n   * - verbose: use -verbose instead of -format (only if necessary b/c its slow)\n   * - helper: use the conversion helper\n   */\n\n  var map = {\n      'format': { key: 'format', format: '%m ', helper: 'Format' }\n    , 'depth':  { key: 'depth',  format: '%q' }\n    , 'filesize': { key: 'Filesize', format: '%b' }\n    , 'size':  { key: 'size', format: '%wx%h ', helper: 'Geometry' }\n    , 'color': { key: 'color', format: '%k',  helper: 'Colors' }\n    , 'orientation': { key: 'Orientation', format: '%[EXIF:Orientation]', helper: 'Orientation' }\n    , 'res':   { key: 'Resolution', verbose: true }\n  }\n\n  /**\n   * Getter functions\n   */\n\n  Object.keys(map).forEach(function (getter) {\n    proto[getter] = function (opts, callback) {\n      if (!callback) callback = opts, opts = {};\n      if (!callback) return this;\n\n      var val = map[getter]\n        , key = val.key\n        , self = this;\n\n      if (self.data[key]) {\n        callback.call(self, null, self.data[key]);\n        return self;\n      }\n\n      self.on(getter, callback);\n\n      self.bufferStream = !!opts.bufferStream;\n\n      if (val.verbose) {\n        self.identify(opts, function (err, stdout, stderr, cmd) {\n          if (err) {\n            self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          } else {\n            self.emit(getter, err, self.data[key]);\n          }\n        });\n        return self;\n      }\n\n      var args = makeArgs(self, val);\n      self._exec(args, function (err, stdout, stderr, cmd) {\n        if (err) {\n          self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          return;\n        }\n\n        var result = (stdout||'').trim();\n\n        if (val.helper in helper) {\n          helper[val.helper](self.data, result);\n        } else {\n          self.data[key] = result;\n        }\n\n        self.emit(getter, err, self.data[key]);\n      });\n\n      return self;\n    }\n  });\n\n  /**\n   * identify command\n   *\n   * Overwrites all internal data with the parsed output\n   * which is more accurate than the fast shortcut\n   * getters.\n   */\n\n  proto.identify = function identify (opts, callback) {\n    // identify with pattern\n    if (typeof(opts) === 'string') {\n      opts = {\n        format: opts\n      }\n    }\n    if (!callback) callback = opts, opts = {};\n    if (!callback) return this;\n    if (opts && opts.format) return identifyPattern.call(this, opts, callback);\n\n    var self = this;\n\n    if (IDENTIFIED === self._identifyState) {\n      callback.call(self, null, self.data);\n      return self;\n    }\n\n    self.on('identify', callback);\n\n    if (IDENTIFYING === self._identifyState) {\n      return self;\n    }\n\n    self._identifyState = IDENTIFYING;\n\n    self.bufferStream = !!opts.bufferStream;\n\n    var args = makeArgs(self, { verbose: true });\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      err = parse(stdout, self);\n\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      self.data.path = self.source;\n\n      self.emit('identify', null, self.data);\n      self._identifyState = IDENTIFIED;\n    });\n\n    return self;\n  }\n\n\n  /**\n   * identify with pattern\n   *\n   * Execute `identify -format` with custom pattern\n   */\n\n  function identifyPattern (opts, callback) {\n    var self = this;\n\n    self.bufferStream = !!opts.bufferStream;\n\n    var args = makeArgs(self, opts);\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        return callback.call(self, err, undefined, stdout, stderr, cmd);\n      }\n\n      callback.call(self, err, (stdout||'').trim());\n    });\n\n    return self;\n  }\n\n\n  /**\n   * Parses `identify` responses.\n   *\n   * @param {String} stdout\n   * @param {Gm} self\n   * @return {Error} [optionally]\n   */\n\n  function parse (stdout, self) {\n    // normalize\n    var parts = (stdout||\"\").trim().replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n\n    // skip the first line (its just the filename)\n    parts.shift();\n\n    try {\n      var len = parts.length\n        , rgx1 = /^( *)(.+?): (.*)$/ // key: val\n        , rgx2 = /^( *)(.+?):$/      // key: begin nested object\n        , out = { indent: {} }\n        , level = null\n        , lastkey\n        , i = 0\n        , res\n        , o\n\n      for (; i < len; ++i) {\n        res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);\n        if (!res) continue;\n\n        var indent = res[1].length\n          , key = res[2] ? res[2].trim() : '';\n\n        if ('Image' == key || 'Warning' == key) continue;\n\n        var val = res[3] ? res[3].trim() : null;\n\n        // first iteration?\n        if (null === level) {\n          level = indent;\n          o = out.root = out.indent[level] = self.data;\n        } else if (indent < level) {\n          // outdent\n          if (!(indent in out.indent)) {\n            continue;\n          }\n          o = out.indent[indent];\n        } else if (indent > level) {\n          // dropping into a nested object\n          out.indent[level] = o;\n          // weird format, key/val pair with nested children. discard the val\n          o = o[lastkey] = {};\n        }\n\n        level = indent;\n\n        if (val) {\n          // if previous key was exist and we got the same key\n          // cast it to an array.\n          if(o.hasOwnProperty(key)){\n            // cast it to an array and dont forget the previous value\n            if(!Array.isArray(o[key])){\n              var tmp = o[key];\n              o[key] = [tmp];\n            }\n\n            // set value\n            o[key].push(val);\n          } else {\n            o[key] = val;\n          }\n\n          if (key in helper) {\n            helper[key](o, val);\n          }\n        }\n\n        lastkey = key;\n      }\n\n    } catch (err) {\n      err.message = err.message + \"\\n\\n  Identify stdout:\\n  \" + stdout;\n      return err;\n    }\n  }\n\n  /**\n   * Create an argument array for the identify command.\n   *\n   * @param {gm} self\n   * @param {Object} val\n   * @return {Array}\n   */\n\n  function makeArgs (self, val) {\n    var args = [\n        'identify'\n      , '-ping'\n    ];\n\n    if (val.format) {\n      args.push('-format', val.format);\n    }\n\n    if (val.verbose) {\n      args.push('-verbose');\n    }\n\n    args = args.concat(self.src());\n    return args;\n  }\n\n  /**\n   * Map exif orientation codes to orientation names.\n   */\n\n  var orientations = {\n      '1': 'TopLeft'\n    , '2': 'TopRight'\n    , '3': 'BottomRight'\n    , '4': 'BottomLeft'\n    , '5': 'LeftTop'\n    , '6': 'RightTop'\n    , '7': 'RightBottom'\n    , '8': 'LeftBottom'\n  }\n\n  /**\n   * identify -verbose helpers\n   */\n\n  var helper = gm.identifyHelpers = {};\n\n  helper.Geometry = function Geometry (o, val) {\n    // We only want the size of the first frame.\n    // Each frame is separated by a space.\n    var split = val.split(\" \").shift().split(\"x\");\n    var width = parseInt(split[0], 10);\n    var height = parseInt(split[1], 10);\n    if (o.size && o.size.width && o.size.height) {\n      if (width > o.size.width) o.size.width = width;\n      if (height > o.size.height) o.size.height = height;\n    } else {\n      o.size = {\n        width:  width,\n        height: height\n      }\n    }\n  };\n\n  helper.Format = function Format (o, val) {\n    o.format = val.split(\" \")[0];\n  };\n\n  helper.Depth = function Depth (o, val) {\n    o.depth = parseInt(val, 10);\n  };\n\n  helper.Colors = function Colors (o, val) {\n    o.color = parseInt(val, 10);\n  };\n\n  helper.Orientation = function Orientation (o, val) {\n    if (val in orientations) {\n      o['Profile-EXIF'] || (o['Profile-EXIF'] = {});\n      o['Profile-EXIF'].Orientation = val;\n      o.Orientation = orientations[val];\n    } else {\n      o.Orientation = val || 'Unknown';\n    }\n  };\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}